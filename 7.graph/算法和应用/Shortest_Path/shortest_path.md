# Dijkstra 算法

- Dijkstra 算法是一种用于计算 单源最短路径 的经典算法，适用于 带非负权重 的有向或无向图。

- Dijkstra 算法是一种 贪心算法。它的 核心思想 是：
从起点出发，不断“扩展”到距离起点最近的节点，并利用这些节点去尝试更新其他节点的最短路径，直到所有节点的最短路径都被确定。

换句话说，算法始终保持一个 “已确定最短路径的集合”，并且在每一步中把离起点最近的“候选节点”加入其中。

- 伪代码示例：

```
function Dijkstra_Simple(Graph, source):
    对于图中每个顶点 v:
        dist[v] ← ∞          // 起点到 v 的距离初始化为无穷大
        visited[v] ← false   // 所有顶点初始都未被访问
    dist[source] ← 0         // 起点到自身距离为 0

    重复 |图中顶点数| 次:
        u ← 所有未访问的顶点中 dist[u] 最小的顶点
        visited[u] ← true    // 标记 u 已被访问

        对于 u 的每个相邻顶点 v:
            边权重 weight ← 图中边(u, v) 的权重
            如果 v 未访问 且 dist[v] > dist[u] + weight:
                dist[v] ← dist[u] + weight  // 通过 u 到 v 更短，更新最短路径

    return dist[] // 表示起点到所有顶点的最短路径
```

## 算法分析

- 时间复杂度：
  - 使用简单数组实现优先队列时，时间复杂度为 O(V^2)，其中 V 是图中顶点的数量。
  - 使用 二叉堆 实现优先队列时，时间复杂度为 O((V + E) log V)，其中 E 是图中边的数量。
  - 使用 斐波那契堆 实现优先队列时，时间复杂度可优化到 O(E + V log V)。
  
- 空间复杂度：O(V)，用于存储距离数组和访问标记数组。


# Floyd-Warshall 算法

- Floyd-Warshall 算法是一种用于计算 所有顶点对最短路径 的经典算法，适用于 带正权重和负权重（但无负权环） 的有向或无向图。

- Floyd-Warshall 算法是一种 动态规划算法。它的 核心思想 是：
通过逐步引入中间顶点，更新任意两顶点之间的最短路径。
初始时，直接使用图中的边权重作为路径长度，然后通过考虑每个顶点作为中间点，尝试更新路径长度，直到所有顶点都被考虑为中间点。  

- 算法具体流程如下：

初始化距离矩阵 dist:

dist[i][j] = 0(若 i=j)
dist[i][j] = 边权（若 i→j 有边）
dist[i][j] = ∞（其余情况）
三重循环更新最短路径

```
for k in 所有顶点:
    for i in 所有顶点:
        for j in 所有顶点:
            if dist[i][k] + dist[k][j] < dist[i][j]:
                dist[i][j] ← dist[i][k] + dist[k][j]
```

输出 dist 矩阵 ：表示所有顶点对之间的最短路径长度。

若顶点数为 n ，则 Floyd Warshall 算法的时间复杂度为 O(n^3)