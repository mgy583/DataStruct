# 栈的常见问题

## 出栈序列合法性判断

1. 核心考点

- 选择题高频，给定入栈顺序 1,2,3,…,n，判断哪个出栈序列不可能

- 通常 n=3 或 n=4，偶尔 n=5

1. 快速判断方法（408应试技巧）

- 方法一：直接模拟法（最稳妥）

```c
bool isValid(int push[], int pop[], int n) {
    int stack[n], top = -1;
    int pushIndex = 0;
    
    for (int i = 0; i < n; i++) {
        int current = pop[i];
        
        // 如果栈为空或栈顶不是当前出栈元素，则压入元素直到匹配
        while (top == -1 || stack[top] != current) {
            if (pushIndex >= n) return false; // 所有元素已入栈仍不匹配
            stack[++top] = push[pushIndex++];
        }
        
        // 匹配成功，出栈
        top--;
    }
    return true;
}
```

- 方法二：观察法（快速解题）

  - 核心规则：对于出栈序列中的任意元素 x，所有比 x 小且还未出现的元素必须是逆序出现。

  - 具体步骤：

    取一个出栈元素 x

    找出所有比 x 小且在 x 后面出栈的元素

    这些元素必须按从大到小的顺序出现

- 例题：入栈 1,2,3,4,5，判断 4,5,3,2,1 是否合法？

    4出栈后，比4小的未出栈元素：3,2,1

    这些元素出现顺序：3 > 2 > 1 ✓

    5出栈后，比5小的已全部出栈 ✓

    所以合法

## 出栈序列计数（卡特兰数）

- 常用公式

$$ Cn=1n+1C2nn=(2n)!(n+1)!n!
$$ Cn​=n+11​C2nn​=(n+1)!n!(2n)!​

n   C_n
0   1
1   1
2   2
3   5
4   14
5   42
6   132

- 问法1："n个元素顺序入栈，出栈序列有多少种？"

    直接选卡特兰数

    注意：如果问"入栈出栈操作序列数"，则是卡特兰数

- 问法2："以下哪个数可能是n个元素出栈序列数？"

    只可能是卡特兰数

    如：3个元素→5种，不是4种或6种

## 三、中缀/后缀表达式
1.  常见优先级：

    括号最高

    乘除高于加减

    同级左结合（除赋值和幂运算外）

2. 中缀转后缀（调度场算法）

- 算法步骤：

    从左到右扫描中缀表达式

    操作数：直接输出

    运算符：

        栈空或栈顶为'('：入栈

        当前优先级 > 栈顶优先级：入栈

        否则：弹出栈顶输出，重复比较

    '('：入栈

    ')'：弹出栈中运算符直到'('

    结束：弹出所有运算符

- 示例：a+b*(c-d) 转后缀

步骤          栈         输出
1. a         空          a
2. +         +          a
3. b         +          a b
4. *         + *        a b
5. (         + * (      a b
6. c         + * (      a b c
7. -         + * ( -    a b c
8. d         + * ( -    a b c d
9. )         弹出到'('  a b c d - * +
结束         清空栈     a b c d - * +

## 3. 后缀表达式求值

- 算法：

    从左到右扫描后缀表达式

    操作数：入栈

    运算符：弹出栈顶两个操作数，运算后结果入栈

    最终栈顶为结果

- 注意：除法注意操作数顺序！先弹出的是右操作数
